import telegram
from telegram import (
    ReplyKeyboardMarkup, KeyboardButton, Update,
    BotCommand, InlineKeyboardButton, InlineKeyboardMarkup, LabeledPrice
)
from telegram.constants import ParseMode, ChatAction
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters,
    ContextTypes, PreCheckoutQueryHandler
)
import logging
import traceback
import os
import asyncio
import nest_asyncio
import json
from datetime import datetime, timedelta, timezone
from typing import Optional, Dict, Any, Tuple, Union, List
import firebase_admin
from firebase_admin import credentials, firestore, initialize_app
from google.cloud.firestore_v1.client import Client as FirestoreClient
from ai_services import AI_MODES, AVAILABLE_TEXT_MODELS, get_ai_service, AIConfig

nest_asyncio.apply()
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
class AppConfig:
    TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "8185454402:AAEgJLaBSaUSyP9Z_zv76Fn0PtEwltAqga0")
    PAYMENT_PROVIDER_TOKEN = os.getenv("PAYMENT_PROVIDER_TOKEN", "390540012:LIVE:70602")
    ADMIN_ID = int(os.getenv("ADMIN_ID", "489230152"))
    FIREBASE_CREDENTIALS_JSON_STR = os.getenv("FIREBASE_CREDENTIALS")
    FIREBASE_CERT_PATH = "gemioracle-firebase-adminsdk-fbsvc-8f89d5b941.json"

    MAX_MESSAGE_LENGTH_TELEGRAM = 4000
    MIN_AI_REQUEST_LENGTH = 4

    DEFAULT_FREE_REQUESTS_GOOGLE_FLASH_DAILY = 72
    DEFAULT_FREE_REQUESTS_GEMINI_2_5_FLASH_PREVIEW_DAILY = 48
    DEFAULT_SUBSCRIPTION_REQUESTS_GOOGLE_FLASH_PREVIEW_DAILY = 75
    DEFAULT_FREE_REQUESTS_CUSTOM_PRO_DAILY = 0
    DEFAULT_SUBSCRIPTION_REQUESTS_CUSTOM_PRO_DAILY = 25
    PRO_SUBSCRIPTION_LEVEL_KEY = "profi_access_v1"
    DEFAULT_FREE_REQUESTS_GROK_DAILY = 3
    DEFAULT_SUBSCRIPTION_REQUESTS_GROK_DAILY = 25
    DEFAULT_FREE_REQUESTS_GPT4O_MINI_DAILY = 3
    DEFAULT_SUBSCRIPTION_REQUESTS_GPT4O_MINI_DAILY = 25

    NEWS_CHANNEL_USERNAME = "@timextech"
    NEWS_CHANNEL_LINK = "https://t.me/timextech"
    NEWS_CHANNEL_BONUS_MODEL_KEY = "custom_api_gemini_2_5_pro"
    NEWS_CHANNEL_BONUS_GENERATIONS = 1

    DEFAULT_AI_MODE_KEY = "universal_ai_basic"
    DEFAULT_MODEL_KEY = "google_gemini_2_0_flash"

CONFIG = AppConfig()

# --- –ö–û–ù–°–¢–ê–ù–¢–´ –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø ---
class BotConstants:
    FS_USERS_COLLECTION = "users"
    FS_BOT_DATA_COLLECTION = "bot_data"
    FS_BOT_DATA_DOCUMENT = "data"
    FS_USER_SUBSCRIPTIONS_KEY = "user_subscriptions"
    FS_ALL_USER_DAILY_COUNTS_KEY = "all_user_daily_counts"

    MENU_MAIN = "main_menu"
    MENU_AI_MODES_SUBMENU = "ai_modes_submenu"
    MENU_MODELS_SUBMENU = "models_submenu"
    MENU_LIMITS_SUBMENU = "limits_submenu"
    MENU_BONUS_SUBMENU = "bonus_submenu"
    MENU_SUBSCRIPTION_SUBMENU = "subscription_submenu"
    MENU_HELP_SUBMENU = "help_submenu"

    CALLBACK_ACTION_SUBMENU = "submenu"
    CALLBACK_ACTION_SET_AGENT = "set_agent"
    CALLBACK_ACTION_SET_MODEL = "set_model"
    CALLBACK_ACTION_SHOW_LIMITS = "show_limits"
    CALLBACK_ACTION_CHECK_BONUS = "check_bonus"
    CALLBACK_ACTION_SHOW_SUBSCRIPTION = "show_subscription"
    CALLBACK_ACTION_SHOW_HELP = "show_help"

    API_TYPE_GOOGLE_GENAI = "google_genai"
    API_TYPE_CUSTOM_HTTP = "custom_http_api"

DEFAULT_MODEL_ID = AVAILABLE_TEXT_MODELS[CONFIG.DEFAULT_MODEL_KEY]["id"]

MENU_STRUCTURE = {
    BotConstants.MENU_MAIN: {
        "title": "üìã –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", "items": [
            {"text": "ü§ñ –ê–≥–µ–Ω—Ç—ã –ò–ò", "action": BotConstants.CALLBACK_ACTION_SUBMENU, "target": BotConstants.MENU_AI_MODES_SUBMENU},
            {"text": "‚öôÔ∏è –ú–æ–¥–µ–ª–∏ –ò–ò", "action": BotConstants.CALLBACK_ACTION_SUBMENU, "target": BotConstants.MENU_MODELS_SUBMENU},
            {"text": "üìä –õ–∏–º–∏—Ç—ã", "action": BotConstants.CALLBACK_ACTION_SUBMENU, "target": BotConstants.MENU_LIMITS_SUBMENU},
            {"text": "üéÅ –ë–æ–Ω—É—Å", "action": BotConstants.CALLBACK_ACTION_SUBMENU, "target": BotConstants.MENU_BONUS_SUBMENU},
            {"text": "üíé –ü–æ–¥–ø–∏—Å–∫–∞", "action": BotConstants.CALLBACK_ACTION_SUBMENU, "target": BotConstants.MENU_SUBSCRIPTION_SUBMENU},
            {"text": "‚ùì –ü–æ–º–æ—â—å", "action": BotConstants.CALLBACK_ACTION_SUBMENU, "target": BotConstants.MENU_HELP_SUBMENU}
        ], "parent": None, "is_submenu": False
    },
    BotConstants.MENU_AI_MODES_SUBMENU: {
        "title": "–í—ã–±–µ—Ä–∏—Ç–µ –∞–≥–µ–Ω—Ç –ò–ò", "items": [
            {"text": mode["name"], "action": BotConstants.CALLBACK_ACTION_SET_AGENT, "target": key}
            for key, mode in AI_MODES.items() if key != "gemini_pro_custom_mode"
        ], "parent": BotConstants.MENU_MAIN, "is_submenu": True
    },
    BotConstants.MENU_MODELS_SUBMENU: {
        "title": "–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –ò–ò", "items": [
            {"text": model["name"], "action": BotConstants.CALLBACK_ACTION_SET_MODEL, "target": key}
            for key, model in AVAILABLE_TEXT_MODELS.items()
        ], "parent": BotConstants.MENU_MAIN, "is_submenu": True
    },
    BotConstants.MENU_LIMITS_SUBMENU: {"title": "–í–∞—à–∏ –ª–∏–º–∏—Ç—ã", "items": [{"text": "üìä –ü–æ–∫–∞–∑–∞—Ç—å", "action": BotConstants.CALLBACK_ACTION_SHOW_LIMITS, "target": "usage"}], "parent": BotConstants.MENU_MAIN, "is_submenu": True},
    BotConstants.MENU_BONUS_SUBMENU: {"title": "–ë–æ–Ω—É—Å –∑–∞ –ø–æ–¥–ø–∏—Å–∫—É", "items": [{"text": "üéÅ –ü–æ–ª—É—á–∏—Ç—å", "action": BotConstants.CALLBACK_ACTION_CHECK_BONUS, "target": "news_bonus"}], "parent": BotConstants.MENU_MAIN, "is_submenu": True},
    BotConstants.MENU_SUBSCRIPTION_SUBMENU: {"title": "–ü–æ–¥–ø–∏—Å–∫–∞ –ü—Ä–æ—Ñ–∏", "items": [{"text": "üíé –ö—É–ø–∏—Ç—å", "action": BotConstants.CALLBACK_ACTION_SHOW_SUBSCRIPTION, "target": "subscribe"}], "parent": BotConstants.MENU_MAIN, "is_submenu": True},
    BotConstants.MENU_HELP_SUBMENU: {"title": "–ü–æ–º–æ—â—å", "items": [{"text": "‚ùì –°–ø—Ä–∞–≤–∫–∞", "action": BotConstants.CALLBACK_ACTION_SHOW_HELP, "target": "help"}], "parent": BotConstants.MENU_MAIN, "is_submenu": True}
}

# --- –°–ï–†–í–ò–° –î–õ–Ø –†–ê–ë–û–¢–´ –° FIRESTORE ---
class FirestoreService:
    def __init__(self, cert_path: str, creds_json_str: Optional[str] = None):
        self._db: Optional[FirestoreClient] = None
        try:
            cred_obj = None
            if creds_json_str:
                try:
                    cred_obj = credentials.Certificate(json.loads(creds_json_str))
                    logger.info("Firebase credentials loaded from JSON string.")
                except json.JSONDecodeError as e:
                    logger.error(f"Error parsing FIREBASE_CREDENTIALS_JSON_STR: {e}. Check JSON env var.")
                    raise
            elif os.path.exists(cert_path):
                cred_obj = credentials.Certificate(cert_path)
                logger.info(f"Firebase credentials loaded from file: {cert_path}.")
            else:
                raise FileNotFoundError("Firebase credentials not configured (JSON string or cert file).")

            if not firebase_admin._apps: # pylint: disable=protected-access
                initialize_app(cred_obj)
                logger.info("Firebase app successfully initialized.")
            else:
                logger.info("Firebase app already initialized.")
            self._db = firestore.client()
            logger.info("Firestore client successfully initialized.")
        except Exception as e:
            logger.error(f"Critical error during Firebase/Firestore initialization: {e}", exc_info=True)
            self._db = None

    async def _execute_firestore_op(self, func, *args, **kwargs):
        if not self._db:
            logger.warning(f"Firestore (db) is not initialized. Operation '{func.__name__}' skipped.")
            return None
        return await asyncio.get_event_loop().run_in_executor(None, lambda: func(*args, **kwargs))

    async def get_user_data(self, user_id: int) -> Dict[str, Any]:
        if not self._db: return {}
        doc_ref = self._db.collection(BotConstants.FS_USERS_COLLECTION).document(str(user_id))
        doc = await self._execute_firestore_op(doc_ref.get)
        return doc.to_dict() if doc and doc.exists else {}

    async def set_user_data(self, user_id: int, data: Dict[str, Any]) -> None:
        if not self._db: return
        doc_ref = self._db.collection(BotConstants.FS_USERS_COLLECTION).document(str(user_id))
        await self._execute_firestore_op(doc_ref.set, data, merge=True)
        logger.debug(f"User data for {user_id} updated with keys: {list(data.keys())}")

    async def get_bot_data(self) -> Dict[str, Any]:
        if not self._db: return {}
        doc_ref = self._db.collection(BotConstants.FS_BOT_DATA_COLLECTION).document(BotConstants.FS_BOT_DATA_DOCUMENT)
        doc = await self._execute_firestore_op(doc_ref.get)
        return doc.to_dict() if doc and doc.exists else {}

    async def set_bot_data(self, data: Dict[str, Any]) -> None:
        if not self._db: return
        doc_ref = self._db.collection(BotConstants.FS_BOT_DATA_COLLECTION).document(BotConstants.FS_BOT_DATA_DOCUMENT)
        await self._execute_firestore_op(doc_ref.set, data, merge=True)
        logger.debug(f"Bot data updated with keys: {list(data.keys())}")

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ä–≤–∏—Å–∞ Firestore
firestore_service = FirestoreService(
    cert_path=CONFIG.FIREBASE_CERT_PATH,
    creds_json_str=CONFIG.FIREBASE_CREDENTIALS_JSON_STR
)

# --- –£–¢–ò–õ–ò–¢–´ –ò –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ---
async def _store_and_try_delete_message(update: Update, user_id: int, is_command_to_keep: bool = False):
    if not update.message: return

    message_id_to_process = update.message.message_id
    timestamp_now_iso = datetime.now(timezone.utc).isoformat()
    chat_id = update.effective_chat.id
    
    user_data_for_msg_handling = await firestore_service.get_user_data(user_id)

    prev_command_info = user_data_for_msg_handling.pop('user_command_to_delete', None)
    if prev_command_info and prev_command_info.get('message_id'):
        try:
            prev_msg_time = datetime.fromisoformat(prev_command_info['timestamp'])
            if prev_msg_time.tzinfo is None: prev_msg_time = prev_msg_time.replace(tzinfo=timezone.utc)
            if datetime.now(timezone.utc) - prev_msg_time <= timedelta(hours=48):
                await update.get_bot().delete_message(chat_id=chat_id, message_id=prev_command_info['message_id'])
                logger.info(f"Successfully deleted previous user message {prev_command_info['message_id']}")
        except (telegram.error.BadRequest, ValueError) as e:
            logger.warning(f"Failed to delete/process previous user message {prev_command_info.get('message_id')}: {e}")
    
    if not is_command_to_keep:
        user_data_for_msg_handling['user_command_to_delete'] = {
            'message_id': message_id_to_process, 'timestamp': timestamp_now_iso
        }
        try:
            await update.get_bot().delete_message(chat_id=chat_id, message_id=message_id_to_process)
            logger.info(f"Successfully deleted current user message {message_id_to_process} (not kept).")
            user_data_for_msg_handling.pop('user_command_to_delete', None)
        except telegram.error.BadRequest as e:
            logger.warning(f"Failed to delete current user message {message_id_to_process}: {e}. Will try next time if stored.")
    else:
         user_data_for_msg_handling['user_command_message_to_keep'] = {
            'message_id': message_id_to_process, 'timestamp': timestamp_now_iso
        }
    await firestore_service.set_user_data(user_id, user_data_for_msg_handling)

def auto_delete_message_decorator(is_command_to_keep: bool = False):
    def decorator(func):
        async def wrapper(update: Update, context: ContextTypes.DEFAULT_TYPE):
            if update.effective_user and update.message:
                 await _store_and_try_delete_message(update, update.effective_user.id, is_command_to_keep)
            return await func(update, context)
        return wrapper
    return decorator

async def get_current_model_key(user_id: int, user_data: Optional[Dict[str, Any]] = None) -> str:
    user_data_loc = user_data if user_data is not None else await firestore_service.get_user_data(user_id)
    selected_id = user_data_loc.get('selected_model_id', DEFAULT_MODEL_ID)
    selected_api_type = user_data_loc.get('selected_api_type')

    if selected_api_type:
        for key, info in AVAILABLE_TEXT_MODELS.items():
            if info["id"] == selected_id and info.get("api_type") == selected_api_type:
                return key
    
    for key, info in AVAILABLE_TEXT_MODELS.items():
        if info["id"] == selected_id:
            if user_data_loc.get('selected_api_type') != info.get("api_type"):
                await firestore_service.set_user_data(user_id, {'selected_api_type': info.get("api_type")})
            return key
            
    default_cfg = AVAILABLE_TEXT_MODELS[CONFIG.DEFAULT_MODEL_KEY]
    await firestore_service.set_user_data(user_id, {
        'selected_model_id': default_cfg["id"], 
        'selected_api_type': default_cfg["api_type"]
    })
    return CONFIG.DEFAULT_MODEL_KEY

async def get_selected_model_details(user_id: int, user_data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    model_key = await get_current_model_key(user_id, user_data)
    return AVAILABLE_TEXT_MODELS.get(model_key, AVAILABLE_TEXT_MODELS[CONFIG.DEFAULT_MODEL_KEY])

async def get_current_mode_details(user_id: int, user_data: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    user_data_loc = user_data if user_data is not None else await firestore_service.get_user_data(user_id)
    current_model_k_loc = await get_current_model_key(user_id, user_data_loc)
    mode_k_loc = user_data_loc.get('current_ai_mode', CONFIG.DEFAULT_AI_MODE_KEY)

    if mode_k_loc not in AI_MODES:
        mode_k_loc = CONFIG.DEFAULT_AI_MODE_KEY
        await firestore_service.set_user_data(user_id, {'current_ai_mode': mode_k_loc})
    
    if current_model_k_loc == "custom_api_gemini_2_5_pro":
        return AI_MODES.get("gemini_pro_custom_mode", AI_MODES[CONFIG.DEFAULT_AI_MODE_KEY])
        
    return AI_MODES.get(mode_k_loc, AI_MODES[CONFIG.DEFAULT_AI_MODE_KEY])

def smart_truncate(text: str, max_length: int) -> Tuple[str, bool]:
    if not isinstance(text, str) or len(text) <= max_length:
        return str(text), False

    suffix = "\n\n(...–æ—Ç–≤–µ—Ç –±—ã–ª —Å–æ–∫—Ä–∞—â–µ–Ω)"
    adjusted_max_length = max_length - len(suffix)

    if adjusted_max_length <= 0:
        return text[:max_length - len("...")] + "...", True 
        
    truncated_text = text[:adjusted_max_length]
    
    for separator in ['\n\n', '. ', '! ', '? ', '\n', ' ']:
        position = truncated_text.rfind(separator)
        if position != -1:
            actual_cut_position = position + (len(separator) if separator != ' ' else 0)
            if actual_cut_position > 0 and actual_cut_position > adjusted_max_length * 0.3:
                 return text[:actual_cut_position].strip() + suffix, True
                 
    return text[:adjusted_max_length].strip() + suffix, True

def is_user_profi_subscriber(subscription_details: Dict[str, Any]) -> bool:
    if not subscription_details: return False
    if subscription_details.get('level') == CONFIG.PRO_SUBSCRIPTION_LEVEL_KEY and \
       subscription_details.get('valid_until'):
        try:
            valid_until_dt = datetime.fromisoformat(subscription_details['valid_until'])
            if valid_until_dt.tzinfo is None:
                valid_until_dt = valid_until_dt.replace(tzinfo=timezone.utc)
            return datetime.now(timezone.utc).date() <= valid_until_dt.date()
        except ValueError:
            logger.warning(f"Invalid date format for 'valid_until': {subscription_details['valid_until']}")
            return False
    return False

async def get_user_actual_limit_for_model(
    user_id: int, 
    model_key: str, 
    user_data: Optional[Dict[str, Any]] = None, 
    bot_data_cache: Optional[Dict[str, Any]] = None
) -> int:
    model_cfg = AVAILABLE_TEXT_MODELS.get(model_key)
    if not model_cfg: return 0

    bot_data_loc = bot_data_cache if bot_data_cache is not None else await firestore_service.get_bot_data()
    user_subscriptions = bot_data_loc.get(BotConstants.FS_USER_SUBSCRIPTIONS_KEY, {}).get(str(user_id), {})
    is_profi_user = is_user_profi_subscriber(user_subscriptions)

    limit_type = model_cfg.get("limit_type")
    base_limit = 0

    if limit_type == "daily_free":
        base_limit = model_cfg.get("limit", 0)
    elif limit_type == "subscription_or_daily_free":
        base_limit = model_cfg.get("subscription_daily_limit", 0) if is_profi_user \
                     else model_cfg.get("limit_if_no_subscription", 0)
    elif limit_type == "subscription_custom_pro":
        base_limit = model_cfg.get("subscription_daily_limit", 0) if is_profi_user \
                     else model_cfg.get("limit_if_no_subscription", 0)
    elif not model_cfg.get("is_limited", False):
        return float('inf')
    else:
        return 0

    user_data_loc = user_data if user_data is not None else await firestore_service.get_user_data(user_id)
    if model_key == CONFIG.NEWS_CHANNEL_BONUS_MODEL_KEY and \
       not is_profi_user and \
       user_data_loc.get('claimed_news_bonus', False):
        base_limit += user_data_loc.get('news_bonus_uses_left', 0)
        
    return base_limit

async def check_and_log_request_attempt(user_id: int, model_key: str) -> Tuple[bool, str, int]:
    today_str = datetime.now(timezone.utc).strftime("%Y-%m-%d")
    model_cfg = AVAILABLE_TEXT_MODELS.get(model_key)

    if not model_cfg or not model_cfg.get("is_limited"):
        return True, "", 0

    user_data_loc = await firestore_service.get_user_data(user_id)
    bot_data_loc = await firestore_service.get_bot_data()
    user_subscriptions = bot_data_loc.get(BotConstants.FS_USER_SUBSCRIPTIONS_KEY, {}).get(str(user_id), {})
    is_profi_user = is_user_profi_subscriber(user_subscriptions)

    if model_key == CONFIG.NEWS_CHANNEL_BONUS_MODEL_KEY and \
       not is_profi_user and \
       user_data_loc.get('claimed_news_bonus', False) and \
       user_data_loc.get('news_bonus_uses_left', 0) > 0:
        return True, "bonus_available", 0

    all_user_daily_counts = bot_data_loc.get(BotConstants.FS_ALL_USER_DAILY_COUNTS_KEY, {})
    user_daily_counts = all_user_daily_counts.get(str(user_id), {})
    model_usage_info = user_daily_counts.get(model_key, {'date': '', 'count': 0})

    if model_usage_info['date'] != today_str:
        model_usage_info = {'date': today_str, 'count': 0}

    current_usage_count = model_usage_info['count']
    
    limit_for_comparison = 0 
    if model_cfg.get("limit_type") == "daily_free":
        limit_for_comparison = model_cfg.get("limit", 0)
    elif model_cfg.get("limit_type") == "subscription_or_daily_free":
        limit_for_comparison = model_cfg.get("subscription_daily_limit", 0) if is_profi_user \
                               else model_cfg.get("limit_if_no_subscription", 0)
    elif model_cfg.get("limit_type") == "subscription_custom_pro":
        limit_for_comparison = model_cfg.get("subscription_daily_limit", 0) if is_profi_user \
                               else model_cfg.get("limit_if_no_subscription", 0)

    if current_usage_count >= limit_for_comparison:
        display_limit = await get_user_actual_limit_for_model(user_id, model_key, user_data_loc, bot_data_loc)
        message_parts = [f"–î–æ—Å—Ç–∏–≥–Ω—É—Ç –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç ({current_usage_count}/{display_limit}) –¥–ª—è –º–æ–¥–µ–ª–∏ ¬´{model_cfg['name']}¬ª. –ú–æ–¥–µ–ª—å –±—ã–ª–∞ –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ ¬´{AVAILABLE_TEXT_MODELS[CONFIG.DEFAULT_MODEL_KEY]['name']}¬ª."]
        
        default_model_config = AVAILABLE_TEXT_MODELS[CONFIG.DEFAULT_MODEL_KEY]
        await firestore_service.set_user_data(user_id, {
            'selected_model_id': default_model_config["id"],
            'selected_api_type': default_model_config.get("api_type")
        })

        if model_key == CONFIG.NEWS_CHANNEL_BONUS_MODEL_KEY and not is_profi_user:
            bonus_model_name = AVAILABLE_TEXT_MODELS.get(CONFIG.NEWS_CHANNEL_BONUS_MODEL_KEY, {}).get("name", "–±–æ–Ω—É—Å–Ω–æ–π –º–æ–¥–µ–ª–∏")
            if not user_data_loc.get('claimed_news_bonus', False):
                message_parts.append(f'üí° –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ <a href="{CONFIG.NEWS_CHANNEL_LINK}">–∫–∞–Ω–∞–ª –Ω–æ–≤–æ—Å—Ç–µ–π</a> –¥–∞—Å—Ç –≤–∞–º –±–æ–Ω—É—Å–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ ({CONFIG.NEWS_CHANNEL_BONUS_GENERATIONS} –¥–ª—è –º–æ–¥–µ–ª–∏ {bonus_model_name})!')
            elif user_data_loc.get('news_bonus_uses_left', 0) == 0:
                message_parts.append(f"‚ÑπÔ∏è –ë–æ–Ω—É—Å —Å <a href='{CONFIG.NEWS_CHANNEL_LINK}'>–∫–∞–Ω–∞–ª–∞ –Ω–æ–≤–æ—Å—Ç–µ–π</a> –¥–ª—è –º–æ–¥–µ–ª–∏ {bonus_model_name} —É–∂–µ –±—ã–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω.")
        
        if not is_profi_user:
            message_parts.append("–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∑–∞–≤—Ç—Ä–∞ –∏–ª–∏ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è <a href='https://t.me/gemini_oracle_bot?start=subscribe'>Profi –ø–æ–¥–ø–∏—Å–∫–∏</a> –¥–ª—è —É–≤–µ–ª–∏—á–µ–Ω–∏—è –ª–∏–º–∏—Ç–æ–≤.")
        
        if model_usage_info['date'] == today_str and user_daily_counts.get(model_key) != model_usage_info:
             user_daily_counts[model_key] = model_usage_info
             all_user_daily_counts[str(user_id)] = user_daily_counts
             await firestore_service.set_bot_data({BotConstants.FS_ALL_USER_DAILY_COUNTS_KEY: all_user_daily_counts})

        return False, "\n".join(message_parts), current_usage_count

    if model_usage_info['date'] == today_str and user_daily_counts.get(model_key) != model_usage_info:
        user_daily_counts[model_key] = model_usage_info
        all_user_daily_counts[str(user_id)] = user_daily_counts
        await firestore_service.set_bot_data({BotConstants.FS_ALL_USER_DAILY_COUNTS_KEY: all_user_daily_counts})
        
    return True, "", current_usage_count

async def increment_request_count(user_id: int, model_key: str):
    model_cfg = AVAILABLE_TEXT_MODELS.get(model_key)
    if not model_cfg or not model_cfg.get("is_limited"):
        return

    user_data_loc = await firestore_service.get_user_data(user_id)
    bot_data_loc = await firestore_service.get_bot_data()
    user_subscriptions = bot_data_loc.get(BotConstants.FS_USER_SUBSCRIPTIONS_KEY, {}).get(str(user_id), {})
    is_profi_user = is_user_profi_subscriber(user_subscriptions)

    if model_key == CONFIG.NEWS_CHANNEL_BONUS_MODEL_KEY and \
       not is_profi_user and \
       user_data_loc.get('claimed_news_bonus', False):
        bonus_uses_left = user_data_loc.get('news_bonus_uses_left', 0)
        if bonus_uses_left > 0:
            await firestore_service.set_user_data(user_id, {'news_bonus_uses_left': bonus_uses_left - 1})
            logger.info(f"User {user_id} consumed a news channel bonus use for model {model_key}. Left: {bonus_uses_left - 1}")
            return

    today_str = datetime.now(timezone.utc).strftime("%Y-%m-%d")
    all_user_daily_counts = bot_data_loc.get(BotConstants.FS_ALL_USER_DAILY_COUNTS_KEY, {})
    user_daily_counts = all_user_daily_counts.get(str(user_id), {})
    
    model_usage_info = user_daily_counts.get(model_key, {'date': today_str, 'count': 0})
    if model_usage_info['date'] != today_str:
        model_usage_info = {'date': today_str, 'count': 0}
    
    model_usage_info['count'] += 1
    user_daily_counts[model_key] = model_usage_info
    all_user_daily_counts[str(user_id)] = user_daily_counts
    
    await firestore_service.set_bot_data({BotConstants.FS_ALL_USER_DAILY_COUNTS_KEY: all_user_daily_counts})
    logger.info(f"Incremented daily count for user {user_id}, model {model_key} to {model_usage_info['count']}.")

# --- –§–£–ù–ö–¶–ò–ò –ú–ï–ù–Æ ---
def is_menu_button_text(text: str) -> bool:
    if text in ["‚¨ÖÔ∏è –ù–∞–∑–∞–¥", "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"]:
        return True
    for menu_data in MENU_STRUCTURE.values():
        for item in menu_data.get("items", []):
            if item["text"] == text:
                return True
    return False

def generate_menu_keyboard(menu_key: str) -> ReplyKeyboardMarkup:
    menu_config = MENU_STRUCTURE.get(menu_key, MENU_STRUCTURE[BotConstants.MENU_MAIN])
    keyboard_rows: List[List[KeyboardButton]] = []
    items = menu_config["items"]

    if menu_key in [BotConstants.MENU_MAIN, BotConstants.MENU_MODELS_SUBMENU]:
        for i in range(0, len(items), 2):
            keyboard_rows.append(
                [KeyboardButton(items[j]["text"]) for j in range(i, min(i + 2, len(items)))]
            )
    else:
        for item in items:
            keyboard_rows.append([KeyboardButton(item["text"])])
            
    if menu_config.get("is_submenu", False):
        navigation_row = [KeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é")]
        if menu_config.get("parent"):
            navigation_row.insert(0, KeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥"))
        keyboard_rows.append(navigation_row)
        
    return ReplyKeyboardMarkup(keyboard_rows, resize_keyboard=True, one_time_keyboard=False)

async def show_menu(update: Update, user_id: int, menu_key: str, user_data_param: Optional[Dict[str, Any]] = None):
    menu_cfg = MENU_STRUCTURE.get(menu_key)
    if not menu_cfg:
        logger.error(f"Menu key '{menu_key}' not found in MENU_STRUCTURE. Defaulting to main menu for user {user_id}.")
        await update.message.reply_text(
            "–û—à–∏–±–∫–∞: –ó–∞–ø—Ä–æ—à–µ–Ω–Ω–æ–µ –º–µ–Ω—é –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü–æ–∫–∞–∑—ã–≤–∞—é –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.",
            reply_markup=generate_menu_keyboard(BotConstants.MENU_MAIN)
        )
        await firestore_service.set_user_data(user_id, {'current_menu': BotConstants.MENU_MAIN})
        return

    await firestore_service.set_user_data(user_id, {'current_menu': menu_key})
    await update.message.reply_text(
        menu_cfg["title"],
        reply_markup=generate_menu_keyboard(menu_key),
        disable_web_page_preview=True
    )
    logger.info(f"User {user_id} was shown menu '{menu_key}'.")

# --- –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ö–û–ú–ê–ù–î TELEGRAM ---
@auto_delete_message_decorator(is_command_to_keep=True)
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_first_name = update.effective_user.first_name
    
    user_data_loc = await firestore_service.get_user_data(user_id)
    updates_to_user_data = {}

    if 'current_ai_mode' not in user_data_loc:
        updates_to_user_data['current_ai_mode'] = CONFIG.DEFAULT_AI_MODE_KEY
    if 'current_menu' not in user_data_loc:
        updates_to_user_data['current_menu'] = BotConstants.MENU_MAIN
        
    default_model_config = AVAILABLE_TEXT_MODELS[CONFIG.DEFAULT_MODEL_KEY]
    if 'selected_model_id' not in user_data_loc:
        updates_to_user_data['selected_model_id'] = default_model_config["id"]
    if 'selected_api_type' not in user_data_loc:
        updates_to_user_data['selected_api_type'] = default_model_config.get("api_type")

    if updates_to_user_data:
        await firestore_service.set_user_data(user_id, updates_to_user_data)
        user_data_loc.update(updates_to_user_data)

    current_model_key_val = await get_current_model_key(user_id, user_data_loc)
    mode_details_res = await get_current_mode_details(user_id, user_data_loc)
    model_details_res = AVAILABLE_TEXT_MODELS.get(current_model_key_val)

    mode_name = mode_details_res['name'] if mode_details_res else "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ–∂–∏–º"
    model_name = model_details_res['name'] if model_details_res else "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –º–æ–¥–µ–ª—å"

    greeting_message = (
        f"üëã –ü—Ä–∏–≤–µ—Ç, {user_first_name}!\n\n"
        f"ü§ñ –¢–µ–∫—É—â–∏–π –∞–≥–µ–Ω—Ç: <b>{mode_name}</b>\n"
        f"‚öôÔ∏è –ê–∫—Ç–∏–≤–Ω–∞—è –º–æ–¥–µ–ª—å: <b>{model_name}</b>\n\n"
        "–Ø –≥–æ—Ç–æ–≤ –∫ –≤–∞—à–∏–º –∑–∞–ø—Ä–æ—Å–∞–º! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –æ–±—â–µ–Ω–∏—è —Å –ò–ò "
        "–∏–ª–∏ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫."
    )
    await update.message.reply_text(
        greeting_message,
        parse_mode=ParseMode.HTML,
        reply_markup=generate_menu_keyboard(BotConstants.MENU_MAIN),
        disable_web_page_preview=True
    )
    await firestore_service.set_user_data(user_id, {'current_menu': BotConstants.MENU_MAIN})
    logger.info(f"User {user_id} ({user_first_name}) started or restarted the bot.")

@auto_delete_message_decorator()
async def open_menu_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    await show_menu(update, user_id, BotConstants.MENU_MAIN)

@auto_delete_message_decorator()
async def usage_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await show_limits(update, update.effective_user.id)

@auto_delete_message_decorator()
async def subscribe_info_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await show_subscription(update, update.effective_user.id)

@auto_delete_message_decorator()
async def get_news_bonus_info_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await claim_news_bonus_logic(update, update.effective_user.id)

@auto_delete_message_decorator()
async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await show_help(update, update.effective_user.id)

# --- –õ–û–ì–ò–ö–ê –û–¢–û–ë–†–ê–ñ–ï–ù–ò–Ø –ò–ù–§–û–†–ú–ê–¶–ò–ò ---
async def show_limits(update: Update, user_id: int):
    user_data_loc = await firestore_service.get_user_data(user_id)
    bot_data_loc = await firestore_service.get_bot_data()
    
    user_subscriptions = bot_data_loc.get(BotConstants.FS_USER_SUBSCRIPTIONS_KEY, {}).get(str(user_id), {})
    is_profi = is_user_profi_subscriber(user_subscriptions)
    
    subscription_status_display = "–ë–µ—Å–ø–ª–∞—Ç–Ω—ã–π"
    if is_profi:
        try:
            valid_until_dt = datetime.fromisoformat(user_subscriptions['valid_until'])
            if valid_until_dt.tzinfo is None: valid_until_dt = valid_until_dt.replace(tzinfo=timezone.utc)
            subscription_status_display = f"–ü—Ä–æ—Ñ–∏ (–∞–∫—Ç–∏–≤–Ω–∞ –¥–æ {valid_until_dt.strftime('%d.%m.%Y')})"
        except (ValueError, KeyError):
            subscription_status_display = "–ü—Ä–æ—Ñ–∏ (–æ—à–∏–±–∫–∞ –≤ –¥–∞—Ç–µ)"
    elif user_subscriptions.get('level') == CONFIG.PRO_SUBSCRIPTION_LEVEL_KEY:
        try:
            expired_dt = datetime.fromisoformat(user_subscriptions['valid_until'])
            if expired_dt.tzinfo is None: expired_dt = expired_dt.replace(tzinfo=timezone.utc)
            subscription_status_display = f"–ü—Ä–æ—Ñ–∏ (–∏—Å—Ç–µ–∫–ª–∞ {expired_dt.strftime('%d.%m.%Y')})"
        except (ValueError, KeyError):
             subscription_status_display = "–ü—Ä–æ—Ñ–∏ (–∏—Å—Ç–µ–∫–ª–∞, –æ—à–∏–±–∫–∞ –≤ –¥–∞—Ç–µ)"

    parts = [f"<b>üìä –í–∞—à–∏ —Ç–µ–∫—É—â–∏–µ –ª–∏–º–∏—Ç—ã</b> (–°—Ç–∞—Ç—É—Å: <b>{subscription_status_display}</b>)\n"]
    today_str = datetime.now(timezone.utc).strftime("%Y-%m-%d")
    all_user_daily_counts = bot_data_loc.get(BotConstants.FS_ALL_USER_DAILY_COUNTS_KEY, {})
    user_counts_today = all_user_daily_counts.get(str(user_id), {})

    for model_key, model_config in AVAILABLE_TEXT_MODELS.items():
        if model_config.get("is_limited"):
            usage_info = user_counts_today.get(model_key, {'date': '', 'count': 0})
            current_day_usage = usage_info['count'] if usage_info['date'] == today_str else 0
            
            actual_limit = await get_user_actual_limit_for_model(user_id, model_key, user_data_loc, bot_data_loc)
            
            bonus_notification = ""
            if model_key == CONFIG.NEWS_CHANNEL_BONUS_MODEL_KEY and \
               not is_profi and \
               user_data_loc.get('claimed_news_bonus', False):
                bonus_left = user_data_loc.get('news_bonus_uses_left', 0)
                if bonus_left > 0:
                    bonus_notification = f" (–≤–∫–ª—é—á–∞—è <b>{bonus_left}</b> –±–æ–Ω—É—Å–Ω—ã—Ö)"
            
            limit_display = '‚àû' if actual_limit == float('inf') else str(actual_limit)
            parts.append(f"‚ñ´Ô∏è {model_config['name']}: <b>{current_day_usage} / {limit_display}</b>{bonus_notification}")

    parts.append("")
    
    bonus_model_cfg = AVAILABLE_TEXT_MODELS.get(CONFIG.NEWS_CHANNEL_BONUS_MODEL_KEY)
    bonus_model_name_display = bonus_model_cfg['name'] if bonus_model_cfg else "–±–æ–Ω—É—Å–Ω–æ–π –º–æ–¥–µ–ª–∏"

    if not user_data_loc.get('claimed_news_bonus', False):
        parts.append(f'üéÅ –ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ <a href="{CONFIG.NEWS_CHANNEL_LINK}">–∫–∞–Ω–∞–ª –Ω–æ–≤–æ—Å—Ç–µ–π</a>, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –±–æ–Ω—É—Å–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ ({CONFIG.NEWS_CHANNEL_BONUS_GENERATIONS} –¥–ª—è {bonus_model_name_display})! –ù–∞–∂–º–∏—Ç–µ ¬´üéÅ –ë–æ–Ω—É—Å¬ª –≤ –º–µ–Ω—é –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏.')
    elif (bonus_left_val := user_data_loc.get('news_bonus_uses_left', 0)) > 0:
        parts.append(f"‚úÖ –£ –≤–∞—Å –µ—Å—Ç—å <b>{bonus_left_val}</b> –±–æ–Ω—É—Å–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π —Å –∫–∞–Ω–∞–ª–∞ –Ω–æ–≤–æ—Å—Ç–µ–π –¥–ª—è –º–æ–¥–µ–ª–∏ {bonus_model_name_display}.")
    else:
        parts.append(f"‚ÑπÔ∏è –ë–æ–Ω—É—Å —Å –∫–∞–Ω–∞–ª–∞ –Ω–æ–≤–æ—Å—Ç–µ–π –¥–ª—è –º–æ–¥–µ–ª–∏ {bonus_model_name_display} –±—ã–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω.")
        
    if not is_profi:
        parts.append("\nüíé –•–æ—Ç–∏—Ç–µ –±–æ–ª—å—à–µ –ª–∏–º–∏—Ç–æ–≤ –∏ –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –º–æ–¥–µ–ª—è–º? –û—Ñ–æ—Ä–º–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É Profi —á–µ—Ä–µ–∑ –∫–æ–º–∞–Ω–¥—É /subscribe –∏–ª–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –∫–Ω–æ–ø–∫—É –≤ –º–µ–Ω—é.")
        
    current_menu_for_reply = user_data_loc.get('current_menu', BotConstants.MENU_LIMITS_SUBMENU)
    await update.message.reply_text(
        "\n".join(parts), 
        parse_mode=ParseMode.HTML, 
        reply_markup=generate_menu_keyboard(current_menu_for_reply),
        disable_web_page_preview=True
    )

async def claim_news_bonus_logic(update: Update, user_id: int):
    user_data_loc = await firestore_service.get_user_data(user_id)
    
    parent_menu_key = user_data_loc.get('current_menu', BotConstants.MENU_BONUS_SUBMENU)
    current_menu_config = MENU_STRUCTURE.get(parent_menu_key, MENU_STRUCTURE[BotConstants.MENU_MAIN])
    reply_menu_key = current_menu_config.get("parent", BotConstants.MENU_MAIN) if current_menu_config.get("is_submenu") else BotConstants.MENU_MAIN

    bonus_model_config = AVAILABLE_TEXT_MODELS.get(CONFIG.NEWS_CHANNEL_BONUS_MODEL_KEY)
    if not bonus_model_config:
        await update.message.reply_text(
            "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –±–æ–Ω—É—Å–Ω–æ–π –º–æ–¥–µ–ª–∏ –≤ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –Ω–µ–∏—Å–ø—Ä–∞–≤–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–æ–æ–±—â–∏—Ç–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.",
            reply_markup=generate_menu_keyboard(reply_menu_key)
        )
        return
        
    bonus_model_name_display = bonus_model_config['name']

    if user_data_loc.get('claimed_news_bonus', False):
        uses_left = user_data_loc.get('news_bonus_uses_left', 0)
        reply_text = f"–í—ã —É–∂–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–ª–∏ –±–æ–Ω—É—Å –∑–∞ –ø–æ–¥–ø–∏—Å–∫—É –Ω–∞ –Ω–æ–≤–æ—Å—Ç–Ω–æ–π –∫–∞–Ω–∞–ª. "
        if uses_left > 0:
            reply_text += f"–£ –≤–∞—Å –æ—Å—Ç–∞–ª–æ—Å—å: <b>{uses_left}</b> –±–æ–Ω—É—Å–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –¥–ª—è –º–æ–¥–µ–ª–∏ {bonus_model_name_display}."
        else:
            reply_text += f"–ë–æ–Ω—É—Å–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–ª—è –º–æ–¥–µ–ª–∏ {bonus_model_name_display} —É–∂–µ –±—ã–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã."
        await update.message.reply_text(
            reply_text, 
            parse_mode=ParseMode.HTML, 
            reply_markup=generate_menu_keyboard(reply_menu_key),
            disable_web_page_preview=True
        )
        return

    try:
        member_status = await update.get_bot().get_chat_member(chat_id=CONFIG.NEWS_CHANNEL_USERNAME, user_id=user_id)
        if member_status.status in ['member', 'administrator', 'creator']:
            await firestore_service.set_user_data(user_id, {
                'claimed_news_bonus': True, 
                'news_bonus_uses_left': CONFIG.NEWS_CHANNEL_BONUS_GENERATIONS
            })
            success_text = (
                f'üéâ –û—Ç–ª–∏—á–Ω–æ! –°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–¥–ø–∏—Å–∫—É –Ω–∞ <a href="{CONFIG.NEWS_CHANNEL_LINK}">{CONFIG.NEWS_CHANNEL_USERNAME}</a>! '
                f"–í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω –±–æ–Ω—É—Å: <b>{CONFIG.NEWS_CHANNEL_BONUS_GENERATIONS}</b> "
                f"–≥–µ–Ω–µ—Ä–∞—Ü–∏–π –¥–ª—è –º–æ–¥–µ–ª–∏ {bonus_model_name_display}."
            )
            await update.message.reply_text(
                success_text, 
                parse_mode=ParseMode.HTML, 
                reply_markup=generate_menu_keyboard(BotConstants.MENU_MAIN), 
                disable_web_page_preview=True
            )
            await firestore_service.set_user_data(user_id, {'current_menu': BotConstants.MENU_MAIN})
        else:
            fail_text = (
                f'–î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –±–æ–Ω—É—Å–∞, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –Ω–∞—à –Ω–æ–≤–æ—Å—Ç–Ω–æ–π –∫–∞–Ω–∞–ª '
                f'<a href="{CONFIG.NEWS_CHANNEL_LINK}">{CONFIG.NEWS_CHANNEL_USERNAME}</a>. '
                f'–ü–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏, –≤–µ—Ä–Ω–∏—Ç–µ—Å—å —Å—é–¥–∞ –∏ —Å–Ω–æ–≤–∞ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É ¬´üéÅ –ü–æ–ª—É—á–∏—Ç—å¬ª –≤ –º–µ–Ω—é ¬´–ë–æ–Ω—É—Å¬ª.'
            )
            inline_keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(f"üì¢ –ü–µ—Ä–µ–π—Ç–∏ –Ω–∞ –∫–∞–Ω–∞–ª {CONFIG.NEWS_CHANNEL_USERNAME}", url=CONFIG.NEWS_CHANNEL_LINK)]
            ])
            await update.message.reply_text(
                fail_text, 
                parse_mode=ParseMode.HTML, 
                reply_markup=inline_keyboard, 
                disable_web_page_preview=True
            )
    except telegram.error.TelegramError as e:
        logger.error(f"Telegram API error during news bonus claim for user {user_id}: {e}", exc_info=True)
        await update.message.reply_text(
            "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –≤–∞—à–µ–π –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –∫–∞–Ω–∞–ª. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –Ω–µ–º–Ω–æ–≥–æ –ø–æ–∑–∂–µ.",
            reply_markup=generate_menu_keyboard(reply_menu_key)
        )
    except Exception as e:
        logger.error(f"Unexpected error during news bonus claim for user {user_id}: {e}", exc_info=True)
        await update.message.reply_text(
            "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π, –µ—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—Å—è.",
            reply_markup=generate_menu_keyboard(reply_menu_key)
        )

async def show_subscription(update: Update, user_id: int):
    user_data_loc = await firestore_service.get_user_data(user_id)
    bot_data_loc = await firestore_service.get_bot_data()
    user_subscriptions = bot_data_loc.get(BotConstants.FS_USER_SUBSCRIPTIONS_KEY, {}).get(str(user_id), {})
    is_active_profi = is_user_profi_subscriber(user_subscriptions)

    parts = ["<b>üíé –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ Profi</b>"]

    if is_active_profi:
        try:
            valid_until_dt = datetime.fromisoformat(user_subscriptions['valid_until'])
            if valid_until_dt.tzinfo is None: valid_until_dt = valid_until_dt.replace(tzinfo=timezone.utc)
            parts.append(f"\n‚úÖ –í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ Profi <b>–∞–∫—Ç–∏–≤–Ω–∞</b> –¥–æ <b>{valid_until_dt.strftime('%d.%m.%Y')}</b>.")
            parts.append("–í–∞–º –¥–æ—Å—Ç—É–ø–Ω—ã —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –ª–∏–º–∏—Ç—ã –∏ –≤—Å–µ –º–æ–¥–µ–ª–∏ –ò–ò.")
        except (ValueError, KeyError):
            parts.append("\n‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –∞–∫—Ç–∏–≤–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞ Profi, –Ω–æ –µ—Å—Ç—å –ø—Ä–æ–±–ª–µ–º–∞ —Å –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º –¥–∞—Ç—ã –æ–∫–æ–Ω—á–∞–Ω–∏—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.")
    else:
        if user_subscriptions.get('level') == CONFIG.PRO_SUBSCRIPTION_LEVEL_KEY:
            try:
                expired_dt = datetime.fromisoformat(user_subscriptions['valid_until'])
                if expired_dt.tzinfo is None: expired_dt = expired_dt.replace(tzinfo=timezone.utc)
                parts.append(f"\n‚ö†Ô∏è –í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ Profi –∏—Å—Ç–µ–∫–ª–∞ <b>{expired_dt.strftime('%d.%m.%Y')}</b>.")
            except (ValueError, KeyError):
                parts.append("\n‚ö†Ô∏è –í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ Profi –∏—Å—Ç–µ–∫–ª–∞ (–æ—à–∏–±–∫–∞ –≤ –¥–∞—Ç–µ).")

        parts.append("\n–ü–æ–¥–ø–∏—Å–∫–∞ <b>Profi</b> –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —Å–ª–µ–¥—É—é—â–∏–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:")
        parts.append("‚ñ´Ô∏è –ó–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ —É–≤–µ–ª–∏—á–µ–Ω–Ω—ã–µ –¥–Ω–µ–≤–Ω—ã–µ –ª–∏–º–∏—Ç—ã –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –º–æ–¥–µ–ª–µ–π –ò–ò.")
        
        pro_models = [m_cfg["name"] for m_key, m_cfg in AVAILABLE_TEXT_MODELS.items() 
                      if m_cfg.get("limit_type") == "subscription_custom_pro" and m_cfg.get("limit_if_no_subscription", -1) == 0]
        if pro_models:
            parts.append(f"‚ñ´Ô∏è –≠–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–º –º–æ–¥–µ–ª—è–º: {', '.join(pro_models)}.")
        else:
             parts.append(f"‚ñ´Ô∏è –î–æ—Å—Ç—É–ø –∫ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–º –º–æ–¥–µ–ª—è–º, —Ç—Ä–µ–±—É—é—â–∏–º –ø–æ–¥–ø–∏—Å–∫—É.")

        parts.append("\n–î–ª—è –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è –∏–ª–∏ –ø—Ä–æ–¥–ª–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–∏ Profi, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /subscribe "
                     "–∏–ª–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –∫–Ω–æ–ø–∫—É ¬´üíé –ö—É–ø–∏—Ç—å¬ª –≤ –º–µ–Ω—é ¬´–ü–æ–¥–ø–∏—Å–∫–∞¬ª.")

    current_menu_for_reply = user_data_loc.get('current_menu', BotConstants.MENU_SUBSCRIPTION_SUBMENU)
    await update.message.reply_text(
        "\n".join(parts), 
        parse_mode=ParseMode.HTML, 
        reply_markup=generate_menu_keyboard(current_menu_for_reply),
        disable_web_page_preview=True
    )

async def show_help(update: Update, user_id: int):
    user_data_loc = await firestore_service.get_user_data(user_id)
    help_text = (
        "<b>‚ùì –°–ø—Ä–∞–≤–∫–∞ –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é –±–æ—Ç–∞</b>\n\n"
        "–Ø –≤–∞—à –º–Ω–æ–≥–æ—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –ò–ò-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç. –í–æ—Ç –∫–∞–∫ —Å–æ –º–Ω–æ–π —Ä–∞–±–æ—Ç–∞—Ç—å:\n\n"
        "1.  <b>–ó–∞–ø—Ä–æ—Å—ã –∫ –ò–ò</b>: –ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å –∏–ª–∏ –∑–∞–¥–∞—á—É –≤ —á–∞—Ç. –Ø –ø–æ—Å—Ç–∞—Ä–∞—é—Å—å –æ—Ç–≤–µ—Ç–∏—Ç—å, –∏—Å–ø–æ–ª—å–∑—É—è —Ç–µ–∫—É—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–≥–µ–Ω—Ç–∞ –∏ –º–æ–¥–µ–ª–∏.\n\n"
        "2.  <b>–ú–µ–Ω—é</b>: –î–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫–æ –≤—Å–µ–º —Ñ—É–Ω–∫—Ü–∏—è–º –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é:\n"
        "    ‚ñ´Ô∏è ¬´<b>ü§ñ –ê–≥–µ–Ω—Ç—ã –ò–ò</b>¬ª: –í—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å –∏–ª–∏ —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –¥–ª—è –ò–ò (–Ω–∞–ø—Ä–∏–º–µ—Ä, '–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π', '–¢–≤–æ—Ä—á–µ—Å–∫–∏–π'). –≠—Ç–æ –≤–ª–∏—è–µ—Ç –Ω–∞ —Å—Ç–∏–ª—å –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ—Å—Ç—å –æ—Ç–≤–µ—Ç–æ–≤.\n"
        "    ‚ñ´Ô∏è ¬´<b>‚öôÔ∏è –ú–æ–¥–µ–ª–∏ –ò–ò</b>¬ª: –ü–µ—Ä–µ–∫–ª—é—á–∞–π—Ç–µ—Å—å –º–µ–∂–¥—É –¥–æ—Å—Ç—É–ø–Ω—ã–º–∏ —è–∑—ã–∫–æ–≤—ã–º–∏ –º–æ–¥–µ–ª—è–º–∏. –†–∞–∑–Ω—ã–µ –º–æ–¥–µ–ª–∏ –º–æ–≥—É—Ç –∏–º–µ—Ç—å —Ä–∞–∑–Ω—ã–µ —Å–∏–ª—å–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã –∏ –ª–∏–º–∏—Ç—ã.\n"
        "    ‚ñ´Ô∏è ¬´<b>üìä –õ–∏–º–∏—Ç—ã</b>¬ª: –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤–∞—à–∏ —Ç–µ–∫—É—â–∏–µ –¥–Ω–µ–≤–Ω—ã–µ –ª–∏–º–∏—Ç—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –¥–ª—è –∫–∞–∂–¥–æ–π –º–æ–¥–µ–ª–∏.\n"
        "    ‚ñ´Ô∏è ¬´<b>üéÅ –ë–æ–Ω—É—Å</b>¬ª: –ü–æ–ª—É—á–∏—Ç–µ –±–æ–Ω—É—Å–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∑–∞ –ø–æ–¥–ø–∏—Å–∫—É –Ω–∞ –Ω–∞—à –Ω–æ–≤–æ—Å—Ç–Ω–æ–π –∫–∞–Ω–∞–ª.\n"
        "    ‚ñ´Ô∏è ¬´<b>üíé –ü–æ–¥–ø–∏—Å–∫–∞</b>¬ª: –£–∑–Ω–∞–π—Ç–µ –æ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞—Ö Profi –ø–æ–¥–ø–∏—Å–∫–∏ –∏ –∫–∞–∫ –µ–µ –æ—Ñ–æ—Ä–º–∏—Ç—å –¥–ª—è —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π.\n"
        "    ‚ñ´Ô∏è ¬´<b>‚ùì –ü–æ–º–æ—â—å</b>¬ª: –≠—Ç–æ—Ç —Ä–∞–∑–¥–µ–ª —Å–ø—Ä–∞–≤–∫–∏.\n\n"
        "3.  <b>–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã</b> (–¥—É–±–ª–∏—Ä—É—é—Ç —Ñ—É–Ω–∫—Ü–∏–∏ –º–µ–Ω—é):\n"
        "    ‚ñ´Ô∏è /start - –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ –±–æ—Ç–∞ –∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è.\n"
        "    ‚ñ´Ô∏è /menu - –û—Ç–∫—Ä—ã—Ç—å –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.\n"
        "    ‚ñ´Ô∏è /usage - –ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—É—â–∏–µ –ª–∏–º–∏—Ç—ã.\n"
        "    ‚ñ´Ô∏è /subscribe - –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ Profi –ø–æ–¥–ø–∏—Å–∫–µ.\n"
        "    ‚ñ´Ô∏è /bonus - –ü–æ–ª—É—á–∏—Ç—å –±–æ–Ω—É—Å –∑–∞ –ø–æ–¥–ø–∏—Å–∫—É –Ω–∞ –∫–∞–Ω–∞–ª.\n"
        "    ‚ñ´Ô∏è /help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É.\n\n"
        "–ï—Å–ª–∏ —É –≤–∞—Å –≤–æ–∑–Ω–∏–∫–Ω—É—Ç –≤–æ–ø—Ä–æ—Å—ã –∏–ª–∏ –ø—Ä–æ–±–ª–µ–º—ã, –Ω–µ —Å—Ç–µ—Å–Ω—è–π—Ç–µ—Å—å –æ–±—Ä–∞—â–∞—Ç—å—Å—è –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ) –∏–ª–∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞ –∫–æ–º–∞–Ω–¥–æ–π /start."
    )
    current_menu_for_reply = user_data_loc.get('current_menu', BotConstants.MENU_HELP_SUBMENU)
    await update.message.reply_text(
        help_text, 
        parse_mode=ParseMode.HTML, 
        reply_markup=generate_menu_keyboard(current_menu_for_reply),
        disable_web_page_preview=True
    )

# --- –û–ë–†–ê–ë–û–¢–ß–ò–ö –ö–ù–û–ü–û–ö –ú–ï–ù–Æ ---
async def menu_button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message or not update.message.text:
        return

    user_id = update.effective_user.id
    button_text = update.message.text.strip()

    if not is_menu_button_text(button_text):
        return 

    try:
        await update.message.delete()
        logger.info(f"Deleted menu button message '{button_text}' from user {user_id}.")
    except telegram.error.TelegramError as e:
        logger.warning(f"Failed to delete menu button message '{button_text}' from user {user_id}: {e}")

    user_data_loc = await firestore_service.get_user_data(user_id)
    current_menu_key = user_data_loc.get('current_menu', BotConstants.MENU_MAIN)
    logger.info(f"User {user_id} pressed menu button '{button_text}' while in menu '{current_menu_key}'.")

    if button_text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
        parent_key = MENU_STRUCTURE.get(current_menu_key, {}).get("parent", BotConstants.MENU_MAIN)
        await show_menu(update, user_id, parent_key, user_data_loc)
        return 
    elif button_text == "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é":
        await show_menu(update, user_id, BotConstants.MENU_MAIN, user_data_loc)
        return

    action_item_found = None
    search_menus_order = [current_menu_key] + [key for key in MENU_STRUCTURE if key != current_menu_key]

    for menu_key_to_search in search_menus_order:
        menu_config_to_search = MENU_STRUCTURE.get(menu_key_to_search, {})
        for item in menu_config_to_search.get("items", []):
            if item["text"] == button_text:
                action_item_found = item
                action_origin_menu_key = menu_key_to_search 
                break
        if action_item_found:
            break
    
    if not action_item_found:
        logger.warning(f"Menu button '{button_text}' pressed by user {user_id} was not matched to any action "
                       f"despite is_menu_button_text() returning True. Current menu was '{current_menu_key}'.")
        await update.message.reply_text(
            "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –≤—ã–±–æ—Ä–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –≤–µ—Ä–Ω–∏—Ç–µ—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.",
            reply_markup=generate_menu_keyboard(current_menu_key)
        )
        return

    action_type = action_item_found["action"]
    action_target = action_item_found["target"]
    return_menu_key_after_action = MENU_STRUCTURE.get(action_origin_menu_key, {}).get("parent", BotConstants.MENU_MAIN)
    if action_origin_menu_key == BotConstants.MENU_MAIN:
        return_menu_key_after_action = BotConstants.MENU_MAIN

    if action_type == BotConstants.CALLBACK_ACTION_SUBMENU:
        await show_menu(update, user_id, action_target, user_data_loc)
    
    elif action_type == BotConstants.CALLBACK_ACTION_SET_AGENT:
        response_message_text = "‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: –í—ã–±—Ä–∞–Ω–Ω—ã–π –∞–≥–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω."
        if action_target in AI_MODES and action_target != "gemini_pro_custom_mode":
            await firestore_service.set_user_data(user_id, {'current_ai_mode': action_target})
            agent_details = AI_MODES[action_target]
            response_message_text = (f"ü§ñ –ê–≥–µ–Ω—Ç –ò–ò –∏–∑–º–µ–Ω–µ–Ω –Ω–∞: <b>{agent_details['name']}</b>.\n"
                                     f"{agent_details.get('welcome', '–ì–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!')}")
        await update.message.reply_text(
            response_message_text, 
            parse_mode=ParseMode.HTML, 
            reply_markup=generate_menu_keyboard(return_menu_key_after_action), 
            disable_web_page_preview=True
        )
        await firestore_service.set_user_data(user_id, {'current_menu': return_menu_key_after_action})

    elif action_type == BotConstants.CALLBACK_ACTION_SET_MODEL:
        response_message_text = "‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: –í—ã–±—Ä–∞–Ω–Ω–∞—è –º–æ–¥–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–∞."
        if action_target in AVAILABLE_TEXT_MODELS:
            model_info = AVAILABLE_TEXT_MODELS[action_target]
            update_payload = {
                'selected_model_id': model_info["id"], 
                'selected_api_type': model_info["api_type"]
            }
            if action_target in ["custom_api_grok_3", "custom_api_gpt_4o_mini"] and \
               user_data_loc.get('current_ai_mode') == "gemini_pro_custom_mode":
                update_payload['current_ai_mode'] = CONFIG.DEFAULT_AI_MODE_KEY
                logger.info(f"User {user_id} selected model {action_target}, AI mode reset from gemini_pro_custom_mode to default.")

            await firestore_service.set_user_data(user_id, update_payload)
            user_data_loc.update(update_payload)

            bot_data_cache = await firestore_service.get_bot_data()
            today_string_val = datetime.now(timezone.utc).strftime("%Y-%m-%d")
            user_model_counts = bot_data_cache.get(BotConstants.FS_ALL_USER_DAILY_COUNTS_KEY, {}).get(str(user_id), {})
            model_daily_usage = user_model_counts.get(action_target, {'date': '', 'count': 0})
            current_usage_string = str(model_daily_usage['count']) if model_daily_usage['date'] == today_string_val else "0"
            
            actual_limit_string = await get_user_actual_limit_for_model(user_id, action_target, user_data_loc, bot_data_cache)
            limit_display_string = '‚àû' if actual_limit_string == float('inf') else str(actual_limit_string)
            
            response_message_text = (f"‚öôÔ∏è –ú–æ–¥–µ–ª—å –ò–ò –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞: <b>{model_info['name']}</b>.\n"
                                     f"–í–∞—à —Ç–µ–∫—É—â–∏–π –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç –¥–ª—è —ç—Ç–æ–π –º–æ–¥–µ–ª–∏: {current_usage_string} / {limit_display_string}.")
        
        await update.message.reply_text(
            response_message_text, 
            parse_mode=ParseMode.HTML, 
            reply_markup=generate_menu_keyboard(return_menu_key_after_action), 
            disable_web_page_preview=True
        )
        await firestore_service.set_user_data(user_id, {'current_menu': return_menu_key_after_action})

    elif action_type == BotConstants.CALLBACK_ACTION_SHOW_LIMITS:
        await show_limits(update, user_id)
    elif action_type == BotConstants.CALLBACK_ACTION_CHECK_BONUS:
        await claim_news_bonus_logic(update, user_id)
    elif action_type == BotConstants.CALLBACK_ACTION_SHOW_SUBSCRIPTION:
        await show_subscription(update, user_id)
    elif action_type == BotConstants.CALLBACK_ACTION_SHOW_HELP:
        await show_help(update, user_id)
    else:
        logger.warning(f"Unknown action type '{action_type}' for button '{button_text}' (target: '{action_target}') by user {user_id}.")
        await update.message.reply_text(
            "–í—ã–±—Ä–∞–Ω–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
            reply_markup=generate_menu_keyboard(current_menu_key)
        )

# --- –û–ë–†–ê–ë–û–¢–ß–ò–ö –¢–ï–ö–°–¢–û–í–´–• –°–û–û–ë–©–ï–ù–ò–ô ---
async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if not update.message or not update.message.text:
        return

    user_message_text = update.message.text.strip()
    await _store_and_try_delete_message(update, user_id, is_command_to_keep=False)

    if is_menu_button_text(user_message_text):
        logger.debug(f"User {user_id} sent menu button text '{user_message_text}' that reached handle_text. Explicitly ignoring.")
        return

    if len(user_message_text) < CONFIG.MIN_AI_REQUEST_LENGTH:
        user_data_cache = await firestore_service.get_user_data(user_id)
        await update.message.reply_text(
            "–í–∞—à –∑–∞–ø—Ä–æ—Å —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å—Ñ–æ—Ä–º—É–ª–∏—Ä—É–π—Ç–µ –µ–≥–æ –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ.",
            reply_markup=generate_menu_keyboard(user_data_cache.get('current_menu', BotConstants.MENU_MAIN))
        )
        return

    logger.info(f"User {user_id} sent AI request (first 100 chars): '{user_message_text[:100]}...'")
    
    user_data_cache = await firestore_service.get_user_data(user_id) 
    current_model_key_val = await get_current_model_key(user_id, user_data_cache)
    
    can_proceed, limit_message, _ = await check_and_log_request_attempt(user_id, current_model_key_val)
    if not can_proceed:
        await update.message.reply_text(
            limit_message, 
            parse_mode=ParseMode.HTML, 
            reply_markup=generate_menu_keyboard(user_data_cache.get('current_menu', BotConstants.MENU_MAIN)), 
            disable_web_page_preview=True
        )
        user_data_cache = await firestore_service.get_user_data(user_id)
        await update.message.reply_text(
             "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥—É—é –º–æ–¥–µ–ª—å –∏–ª–∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –ø–æ–∑–∂–µ.",
             reply_markup=generate_menu_keyboard(user_data_cache.get('current_menu', BotConstants.MENU_MAIN))
        )
        return

    current_model_key_val = await get_current_model_key(user_id, user_data_cache)
    ai_service = get_ai_service(current_model_key_val)

    if not ai_service:
        logger.critical(f"Could not get AI service for model key '{current_model_key_val}' for user {user_id}.")
        await update.message.reply_text(
            "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–±–æ—Ä–µ AI –º–æ–¥–µ–ª–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–æ–æ–±—â–∏—Ç–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –∏–ª–∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ /start.",
            reply_markup=generate_menu_keyboard(user_data_cache.get('current_menu', BotConstants.MENU_MAIN))
        )
        return

    await context.bot.send_chat_action(
        chat_id=update.effective_chat.id,
        action=ChatAction.TYPING
    )

    mode_details = await get_current_mode_details(user_id, user_data_cache)
    system_prompt = mode_details.get('prompt', '')
    
    try:
        response_text = await ai_service.generate_response(system_prompt, user_message_text)
        response_text_truncated, was_truncated = smart_truncate(response_text, CONFIG.MAX_MESSAGE_LENGTH_TELEGRAM)
        
        if was_truncated:
            logger.info(f"Response for user {user_id} was truncated from {len(response_text)} to {len(response_text_truncated)} chars.")
        
        await update.message.reply_text(
            response_text_truncated,
            parse_mode=ParseMode.HTML,
            reply_markup=generate_menu_keyboard(user_data_cache.get('current_menu', BotConstants.MENU_MAIN)),
            disable_web_page_preview=True
        )
        
        await increment_request_count(user_id, current_model_key_val)
        logger.info(f"Successfully processed AI request for user {user_id} with model {current_model_key_val}.")
        
    except Exception as e:
        logger.error(f"Error generating AI response for user {user_id} with model {current_model_key_val}: {e}", exc_info=True)
        error_message = (
            f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞: {str(e)}.\n"
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥—É—é –º–æ–¥–µ–ª—å –ò–ò."
        )
        await update.message.reply_text(
            error_message,
            reply_markup=generate_menu_keyboard(user_data_cache.get('current_menu', BotConstants.MENU_MAIN))
        )

# --- –ì–õ–ê–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –ò –ó–ê–ü–£–°–ö –ë–û–¢–ê ---
async def main():
    app = Application.builder().token(CONFIG.TELEGRAM_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("menu", open_menu_command))
    app.add_handler(CommandHandler("usage", usage_command))
    app.add_handler(CommandHandler("subscribe", subscribe_info_command))
    app.add_handler(CommandHandler("bonus", get_news_bonus_info_command))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, menu_button_handler))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))

    try:
        logger.info("Starting bot polling...")
        await app.run_polling(allowed_updates=Update.ALL_TYPES)
    except Exception as e:
        logger.critical(f"Critical error in bot polling: {e}", exc_info=True)
        raise

if __name__ == '__main__':
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("Bot stopped by user.")
    except Exception as e:
        logger.critical(f"Failed to start bot: {e}", exc_info=True)
