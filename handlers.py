# handlers.py
import traceback
from datetime import datetime, timezone, timedelta
import telegram
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.constants import ParseMode, ChatAction
from telegram.ext import ContextTypes

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –≤—Å—ë –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –∏–∑ –æ–±—â–µ–≥–æ —Ñ–∞–π–ª–∞ config.py
from config import (
    firestore_service, CONFIG, BotConstants, AVAILABLE_TEXT_MODELS,
    AI_MODES, MENU_STRUCTURE, auto_delete_message_decorator,
    get_current_model_key, get_current_mode_details, get_user_actual_limit_for_model,
    is_menu_button_text, generate_menu_keyboard, _store_and_try_delete_message,
    check_and_log_request_attempt, get_ai_service, smart_truncate,
    increment_request_count, is_user_profi_subscriber, logger, show_menu
)

# --- –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ö–û–ú–ê–ù–î TELEGRAM ---

@auto_delete_message_decorator(is_command_to_keep=True)
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_first_name = update.effective_user.first_name
    
    user_data_loc = await firestore_service.get_user_data(user_id)
    updates_to_user_data = {}

    if 'current_ai_mode' not in user_data_loc:
        updates_to_user_data['current_ai_mode'] = CONFIG.DEFAULT_AI_MODE_KEY
    if 'current_menu' not in user_data_loc:
        updates_to_user_data['current_menu'] = BotConstants.MENU_MAIN
        
    default_model_config = AVAILABLE_TEXT_MODELS[CONFIG.DEFAULT_MODEL_KEY]
    if 'selected_model_id' not in user_data_loc:
        updates_to_user_data['selected_model_id'] = default_model_config["id"]
    if 'selected_api_type' not in user_data_loc:
        updates_to_user_data['selected_api_type'] = default_model_config.get("api_type")

    if updates_to_user_data:
        await firestore_service.set_user_data(user_id, updates_to_user_data)
        user_data_loc.update(updates_to_user_data)

    current_model_key_val = await get_current_model_key(user_id, user_data_loc)
    mode_details_res = await get_current_mode_details(user_id, user_data_loc)
    model_details_res = AVAILABLE_TEXT_MODELS.get(current_model_key_val)

    mode_name = mode_details_res['name'] if mode_details_res else "N/A"
    model_name = model_details_res['name'] if model_details_res else "N/A"

    greeting_message = (
        f"üëã –ü—Ä–∏–≤–µ—Ç, {user_first_name}!\n\n"
        f"ü§ñ –¢–µ–∫—É—â–∏–π –∞–≥–µ–Ω—Ç: <b>{mode_name}</b>\n"
        f"‚öôÔ∏è –ê–∫—Ç–∏–≤–Ω–∞—è –º–æ–¥–µ–ª—å: <b>{model_name}</b>\n\n"
        "–Ø –≥–æ—Ç–æ–≤ –∫ –≤–∞—à–∏–º –∑–∞–ø—Ä–æ—Å–∞–º! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –æ–±—â–µ–Ω–∏—è —Å –ò–ò "
        "–∏–ª–∏ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫."
    )
    await update.message.reply_text(
        greeting_message,
        parse_mode=ParseMode.HTML,
        reply_markup=generate_menu_keyboard(BotConstants.MENU_MAIN),
        disable_web_page_preview=True
    )
    await firestore_service.set_user_data(user_id, {'current_menu': BotConstants.MENU_MAIN})
    logger.info(f"User {user_id} ({user_first_name}) started the bot.")

@auto_delete_message_decorator()
async def open_menu_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await show_menu(update, update.effective_user.id, BotConstants.MENU_MAIN)

@auto_delete_message_decorator()
async def usage_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await show_limits(update, update.effective_user.id)

@auto_delete_message_decorator()
async def subscribe_info_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await show_subscription(update, update.effective_user.id)

@auto_delete_message_decorator()
async def get_news_bonus_info_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await claim_news_bonus_logic(update, update.effective_user.id)

@auto_delete_message_decorator()
async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await show_help(update, update.effective_user.id)

# --- –õ–û–ì–ò–ö–ê –û–¢–û–ë–†–ê–ñ–ï–ù–ò–Ø –ò–ù–§–û–†–ú–ê–¶–ò–ò ---

async def show_limits(update: Update, user_id: int):
    user_data_loc = await firestore_service.get_user_data(user_id)
    bot_data_loc = await firestore_service.get_bot_data()
    
    user_subscriptions = bot_data_loc.get(BotConstants.FS_USER_SUBSCRIPTIONS_KEY, {}).get(str(user_id), {})
    is_profi = is_user_profi_subscriber(user_subscriptions)
    
    subscription_status_display = "–ë–µ—Å–ø–ª–∞—Ç–Ω—ã–π"
    if is_profi:
        try:
            valid_until_dt = datetime.fromisoformat(user_subscriptions['valid_until']).astimezone(timezone.utc)
            subscription_status_display = f"–ü—Ä–æ—Ñ–∏ (–∞–∫—Ç–∏–≤–Ω–∞ –¥–æ {valid_until_dt.strftime('%d.%m.%Y')})"
        except (ValueError, KeyError):
            subscription_status_display = "–ü—Ä–æ—Ñ–∏ (–æ—à–∏–±–∫–∞ –≤ –¥–∞—Ç–µ)"
    elif user_subscriptions.get('level') == CONFIG.PRO_SUBSCRIPTION_LEVEL_KEY:
        try:
            expired_dt = datetime.fromisoformat(user_subscriptions['valid_until']).astimezone(timezone.utc)
            subscription_status_display = f"–ü—Ä–æ—Ñ–∏ (–∏—Å—Ç–µ–∫–ª–∞ {expired_dt.strftime('%d.%m.%Y')})"
        except (ValueError, KeyError):
             subscription_status_display = "–ü—Ä–æ—Ñ–∏ (–∏—Å—Ç–µ–∫–ª–∞, –æ—à–∏–±–∫–∞ –≤ –¥–∞—Ç–µ)"

    parts = [f"<b>üìä –í–∞—à–∏ —Ç–µ–∫—É—â–∏–µ –ª–∏–º–∏—Ç—ã</b> (–°—Ç–∞—Ç—É—Å: <b>{subscription_status_display}</b>)\n"]
    today_str = datetime.now(timezone.utc).strftime("%Y-%m-%d")
    user_counts_today = bot_data_loc.get(BotConstants.FS_ALL_USER_DAILY_COUNTS_KEY, {}).get(str(user_id), {})

    for model_key, model_config in AVAILABLE_TEXT_MODELS.items():
        if model_config.get("is_limited"):
            usage_info = user_counts_today.get(model_key, {'date': '', 'count': 0})
            current_day_usage = usage_info['count'] if usage_info.get('date') == today_str else 0
            actual_limit = await get_user_actual_limit_for_model(user_id, model_key, user_data_loc, bot_data_loc)
            
            bonus_notification = ""
            if model_key == CONFIG.NEWS_CHANNEL_BONUS_MODEL_KEY and not is_profi and user_data_loc.get('claimed_news_bonus', False):
                bonus_left = user_data_loc.get('news_bonus_uses_left', 0)
                if bonus_left > 0:
                    bonus_notification = f" (–≤–∫–ª—é—á–∞—è <b>{bonus_left}</b> –±–æ–Ω—É—Å–Ω—ã—Ö)"
            
            limit_display = '‚àû' if actual_limit == float('inf') else str(int(actual_limit))
            parts.append(f"‚ñ´Ô∏è {model_config['name']}: <b>{current_day_usage} / {limit_display}</b>{bonus_notification}")

    parts.append("")
    bonus_model_name_display = AVAILABLE_TEXT_MODELS.get(CONFIG.NEWS_CHANNEL_BONUS_MODEL_KEY, {}).get('name', '–±–æ–Ω—É—Å–Ω–æ–π –º–æ–¥–µ–ª–∏')

    if not user_data_loc.get('claimed_news_bonus', False):
        parts.append(f'üéÅ –ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ <a href="{CONFIG.NEWS_CHANNEL_LINK}">–∫–∞–Ω–∞–ª –Ω–æ–≤–æ—Å—Ç–µ–π</a>, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –±–æ–Ω—É—Å–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ ({CONFIG.NEWS_CHANNEL_BONUS_GENERATIONS} –¥–ª—è {bonus_model_name_display})! –ù–∞–∂–º–∏—Ç–µ ¬´üéÅ –ë–æ–Ω—É—Å¬ª –≤ –º–µ–Ω—é.')
    elif (bonus_left_val := user_data_loc.get('news_bonus_uses_left', 0)) > 0:
        parts.append(f"‚úÖ –£ –≤–∞—Å –µ—Å—Ç—å <b>{bonus_left_val}</b> –±–æ–Ω—É—Å–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –¥–ª—è –º–æ–¥–µ–ª–∏ {bonus_model_name_display}.")
    else:
        parts.append(f"‚ÑπÔ∏è –ë–æ–Ω—É—Å —Å –∫–∞–Ω–∞–ª–∞ –Ω–æ–≤–æ—Å—Ç–µ–π –¥–ª—è –º–æ–¥–µ–ª–∏ {bonus_model_name_display} –±—ã–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω.")
        
    if not is_profi:
        parts.append("\nüíé –•–æ—Ç–∏—Ç–µ –±–æ–ª—å—à–µ –ª–∏–º–∏—Ç–æ–≤? –û—Ñ–æ—Ä–º–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É Profi —á–µ—Ä–µ–∑ –∫–æ–º–∞–Ω–¥—É /subscribe –∏–ª–∏ –º–µ–Ω—é.")
        
    current_menu_for_reply = user_data_loc.get('current_menu', BotConstants.MENU_MAIN)
    await update.message.reply_text(
        "\n".join(parts), parse_mode=ParseMode.HTML, 
        reply_markup=generate_menu_keyboard(current_menu_for_reply),
        disable_web_page_preview=True
    )

async def claim_news_bonus_logic(update: Update, user_id: int):
    user_data_loc = await firestore_service.get_user_data(user_id)
    parent_menu_key = user_data_loc.get('current_menu', BotConstants.MENU_MAIN)
    reply_menu_key = MENU_STRUCTURE.get(parent_menu_key, {}).get("parent", BotConstants.MENU_MAIN)

    bonus_model_config = AVAILABLE_TEXT_MODELS.get(CONFIG.NEWS_CHANNEL_BONUS_MODEL_KEY)
    if not bonus_model_config:
        await update.message.reply_text("–û—à–∏–±–∫–∞: –ë–æ–Ω—É—Å–Ω–∞—è –º–æ–¥–µ–ª—å –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞.", reply_markup=generate_menu_keyboard(reply_menu_key))
        return
        
    bonus_model_name = bonus_model_config['name']

    if user_data_loc.get('claimed_news_bonus', False):
        uses_left = user_data_loc.get('news_bonus_uses_left', 0)
        reply_text = f"–í—ã —É–∂–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–ª–∏ –±–æ–Ω—É—Å. " + (f"–£ –≤–∞—Å –æ—Å—Ç–∞–ª–æ—Å—å: <b>{uses_left}</b> –±–æ–Ω—É—Å–Ω—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –¥–ª—è {bonus_model_name}." if uses_left > 0 else f"–ë–æ–Ω—É—Å–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–ª—è {bonus_model_name} –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã.")
        await update.message.reply_text(reply_text, parse_mode=ParseMode.HTML, reply_markup=generate_menu_keyboard(reply_menu_key))
        return

    try:
        member_status = await update.get_bot().get_chat_member(chat_id=CONFIG.NEWS_CHANNEL_USERNAME, user_id=user_id)
        if member_status.status in ['member', 'administrator', 'creator']:
            await firestore_service.set_user_data(user_id, {
                'claimed_news_bonus': True, 
                'news_bonus_uses_left': CONFIG.NEWS_CHANNEL_BONUS_GENERATIONS
            })
            success_text = (f'üéâ –°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–¥–ø–∏—Å–∫—É –Ω–∞ <a href="{CONFIG.NEWS_CHANNEL_LINK}">{CONFIG.NEWS_CHANNEL_USERNAME}</a>! '
                            f"–í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω –±–æ–Ω—É—Å: <b>{CONFIG.NEWS_CHANNEL_BONUS_GENERATIONS}</b> –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –¥–ª—è –º–æ–¥–µ–ª–∏ {bonus_model_name}.")
            await update.message.reply_text(success_text, parse_mode=ParseMode.HTML, reply_markup=generate_menu_keyboard(BotConstants.MENU_MAIN))
            await firestore_service.set_user_data(user_id, {'current_menu': BotConstants.MENU_MAIN})
        else:
            fail_text = (f'–°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ <a href="{CONFIG.NEWS_CHANNEL_LINK}">{CONFIG.NEWS_CHANNEL_USERNAME}</a>, '
                         f'–∞ –∑–∞—Ç–µ–º –≤–µ—Ä–Ω–∏—Ç–µ—Å—å –∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –µ—â–µ —Ä–∞–∑.')
            await update.message.reply_text(fail_text, parse_mode=ParseMode.HTML, reply_markup=generate_menu_keyboard(parent_menu_key))
    except telegram.error.TelegramError as e:
        logger.error(f"Bonus claim error for user {user_id}: {e}", exc_info=True)
        await update.message.reply_text("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ø–æ–¥–ø–∏—Å–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", reply_markup=generate_menu_keyboard(reply_menu_key))

async def show_subscription(update: Update, user_id: int):
    # ... (–∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ –ø—Ä–µ–¥—ã–¥—É—â–∏–º –≤–µ—Ä—Å–∏—è–º, –Ω–æ —Å –∏–º–ø–æ—Ä—Ç–∞–º–∏ –∏–∑ config) ...
    user_data_loc = await firestore_service.get_user_data(user_id)
    bot_data_loc = await firestore_service.get_bot_data()
    user_subscriptions = bot_data_loc.get(BotConstants.FS_USER_SUBSCRIPTIONS_KEY, {}).get(str(user_id), {})
    is_active_profi = is_user_profi_subscriber(user_subscriptions)

    parts = ["<b>üíé –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ Profi</b>"]
    if is_active_profi:
        valid_until_str = user_subscriptions.get('valid_until', 'N/A')
        try:
            valid_until_dt = datetime.fromisoformat(valid_until_str).strftime('%d.%m.%Y')
            parts.append(f"\n‚úÖ –í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ Profi <b>–∞–∫—Ç–∏–≤–Ω–∞</b> –¥–æ <b>{valid_until_dt}</b>.")
        except ValueError:
            parts.append("\n‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –∞–∫—Ç–∏–≤–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞, –Ω–æ –ø—Ä–æ–±–ª–µ–º–∞ —Å –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º –¥–∞—Ç—ã.")
    else:
        # ... (–ª–æ–≥–∏–∫–∞ –¥–ª—è –Ω–µ-–ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤) ...
        parts.append("\n–ü–æ–¥–ø–∏—Å–∫–∞ <b>Profi</b> –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –ª–∏–º–∏—Ç—ã –∏ –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –º–æ–¥–µ–ª—è–º.")
    
    current_menu = user_data_loc.get('current_menu', BotConstants.MENU_MAIN)
    await update.message.reply_text("\n".join(parts), parse_mode=ParseMode.HTML, reply_markup=generate_menu_keyboard(current_menu), disable_web_page_preview=True)


async def show_help(update: Update, user_id: int):
    # ... (–∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ –ø—Ä–µ–¥—ã–¥—É—â–∏–º –≤–µ—Ä—Å–∏—è–º, –Ω–æ —Å –∏–º–ø–æ—Ä—Ç–∞–º–∏ –∏–∑ config) ...
    user_data_loc = await firestore_service.get_user_data(user_id)
    help_text = "<b>‚ùì –°–ø—Ä–∞–≤–∫–∞ –ø–æ –±–æ—Ç—É</b>\n\n1. <b>–ó–∞–ø—Ä–æ—Å—ã:</b> –ü—Ä–æ—Å—Ç–æ –ø–∏—à–∏—Ç–µ –≤ —á–∞—Ç.\n2. <b>–ú–µ–Ω—é:</b> –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫." # –£–ø—Ä–æ—â–µ–Ω–æ –¥–ª—è –ø—Ä–∏–º–µ—Ä–∞
    current_menu = user_data_loc.get('current_menu', BotConstants.MENU_MAIN)
    await update.message.reply_text(help_text, parse_mode=ParseMode.HTML, reply_markup=generate_menu_keyboard(current_menu), disable_web_page_preview=True)

# --- –û–ë–†–ê–ë–û–¢–ß–ò–ö –ö–ù–û–ü–û–ö –ú–ï–ù–Æ ---
async def menu_button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –¢–û–õ–¨–ö–û –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ –∫–Ω–æ–ø–∫–∏ ReplyKeyboardMarkup.
    –ò–º–µ–µ—Ç –±–æ–ª–µ–µ –≤—ã—Å–æ–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç, —á–µ–º handle_text.
    """
    if not update.message or not update.message.text:
        return

    button_text = update.message.text.strip()

    # –ï—Å–ª–∏ —ç—Ç–æ –Ω–µ —Ç–µ–∫—Å—Ç –∫–Ω–æ–ø–∫–∏ –∏–∑ –Ω–∞—à–µ–≥–æ –º–µ–Ω—é, —Ç–æ —ç—Ç–æ—Ç –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ—Ç,
    # –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –æ–±—Ä–∞–±–æ—Ç—á–∏–∫—É (handle_text).
    if not is_menu_button_text(button_text):
        return

    user_id = update.effective_user.id
    logger.info(f"User {user_id} pressed menu button: '{button_text}'")
    
    # –ö–Ω–æ–ø–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞, —É–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –Ω–µ–π
    try:
        await update.message.delete()
    except telegram.error.TelegramError as e:
        logger.warning(f"Failed to delete menu button message '{button_text}': {e}")

    user_data_loc = await firestore_service.get_user_data(user_id)
    current_menu_key = user_data_loc.get('current_menu', BotConstants.MENU_MAIN)

    # –û–±—Ä–∞–±–æ—Ç–∫–∞ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã—Ö –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã—Ö –∫–Ω–æ–ø–æ–∫
    if button_text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
        parent_key = MENU_STRUCTURE.get(current_menu_key, {}).get("parent", BotConstants.MENU_MAIN)
        await show_menu(update, user_id, parent_key)
        return
    elif button_text == "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é":
        await show_menu(update, user_id, BotConstants.MENU_MAIN)
        return

    # –ü–æ–∏—Å–∫ –¥–µ–π—Å—Ç–≤–∏—è –¥–ª—è –Ω–∞–∂–∞—Ç–æ–π –∫–Ω–æ–ø–∫–∏ –ø–æ –≤—Å–µ–º –º–µ–Ω—é (–¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏)
    action_item_found = None
    search_order = [current_menu_key] + [key for key in MENU_STRUCTURE if key != current_menu_key]
    
    for menu_key in search_order:
        for item in MENU_STRUCTURE.get(menu_key, {}).get("items", []):
            if item["text"] == button_text:
                action_item_found = item
                break
        if action_item_found:
            break
    
    if not action_item_found:
        logger.error(f"Button '{button_text}' was identified as a menu button, but no action was found.")
        await show_menu(update, user_id, BotConstants.MENU_MAIN) # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –ø—Ä–∏ –æ—à–∏–±–∫–µ
        return

    # –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è
    action_type = action_item_found["action"]
    action_target = action_item_found["target"]

    if action_type == BotConstants.CALLBACK_ACTION_SUBMENU:
        await show_menu(update, user_id, action_target)
    
    elif action_type == BotConstants.CALLBACK_ACTION_SET_AGENT:
        await firestore_service.set_user_data(user_id, {'current_ai_mode': action_target})
        agent_name = AI_MODES.get(action_target, {}).get('name', 'N/A')
        response_text = f"ü§ñ –ê–≥–µ–Ω—Ç –ò–ò –∏–∑–º–µ–Ω–µ–Ω –Ω–∞: <b>{agent_name}</b>."
        # –ü–æ—Å–ª–µ —Å–º–µ–Ω—ã –∞–≥–µ–Ω—Ç–∞, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –¥–ª—è —è—Å–Ω–æ—Å—Ç–∏
        await update.message.reply_text(response_text, parse_mode=ParseMode.HTML, reply_markup=generate_menu_keyboard(BotConstants.MENU_MAIN))
        await firestore_service.set_user_data(user_id, {'current_menu': BotConstants.MENU_MAIN})

    elif action_type == BotConstants.CALLBACK_ACTION_SET_MODEL:
        model_info = AVAILABLE_TEXT_MODELS.get(action_target, {})
        await firestore_service.set_user_data(user_id, {'selected_model_id': model_info.get("id"), 'selected_api_type': model_info.get("api_type")})
        response_text = f"‚öôÔ∏è –ú–æ–¥–µ–ª—å –ò–ò –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞: <b>{model_info.get('name', 'N/A')}</b>."
        # –ü–æ—Å–ª–µ —Å–º–µ–Ω—ã –º–æ–¥–µ–ª–∏, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
        await update.message.reply_text(response_text, parse_mode=ParseMode.HTML, reply_markup=generate_menu_keyboard(BotConstants.MENU_MAIN))
        await firestore_service.set_user_data(user_id, {'current_menu': BotConstants.MENU_MAIN})

    elif action_type == BotConstants.CALLBACK_ACTION_SHOW_LIMITS:
        await show_limits(update, user_id)
    elif action_type == BotConstants.CALLBACK_ACTION_CHECK_BONUS:
        await claim_news_bonus_logic(update, user_id)
    elif action_type == BotConstants.CALLBACK_ACTION_SHOW_SUBSCRIPTION:
        await show_subscription(update, user_id)
    elif action_type == BotConstants.CALLBACK_ACTION_SHOW_HELP:
        await show_help(update, user_id)
    else:
        logger.warning(f"Unknown action type '{action_type}' for button '{button_text}'")
        await show_menu(update, user_id, BotConstants.MENU_MAIN)


# --- –û–ë–†–ê–ë–û–¢–ß–ò–ö –¢–ï–ö–°–¢–û–í–´–• –°–û–û–ë–©–ï–ù–ò–ô (–ó–ê–ü–†–û–°–´ –ö AI) ---
async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ–±—ã—á–Ω—ã–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –ù–ï —è–≤–ª—è—é—Ç—Å—è –∫–Ω–æ–ø–∫–∞–º–∏ –º–µ–Ω—é.
    """
    # –≠—Ç–æ—Ç –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–µ –¥–æ–ª–∂–µ–Ω —Å—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –Ω–∞ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é.
    # –≠—Ç–æ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π, –µ—Å–ª–∏ —á—Ç–æ-—Ç–æ –ø–æ–π–¥–µ—Ç –Ω–µ —Ç–∞–∫ —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º–∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤.
    if not update.message or not update.message.text or is_menu_button_text(update.message.text.strip()):
        return
        
    user_id = update.effective_user.id
    user_message_text = update.message.text.strip()

    # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, —á—Ç–æ–±—ã –Ω–µ –∑–∞—Å–æ—Ä—è—Ç—å —á–∞—Ç
    await _store_and_try_delete_message(update, user_id, is_command_to_keep=False)

    if len(user_message_text) < CONFIG.MIN_AI_REQUEST_LENGTH:
        user_data_cache = await firestore_service.get_user_data(user_id)
        current_menu = user_data_cache.get('current_menu', BotConstants.MENU_MAIN)
        await update.message.reply_text(
            "–í–∞—à –∑–∞–ø—Ä–æ—Å —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å—Ñ–æ—Ä–º—É–ª–∏—Ä—É–π—Ç–µ –µ–≥–æ –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ.",
            reply_markup=generate_menu_keyboard(current_menu)
        )
        return

    logger.info(f"User {user_id} sent AI request: '{user_message_text[:100]}...'")
    
    user_data_cache = await firestore_service.get_user_data(user_id) 
    current_model_key = await get_current_model_key(user_id, user_data_cache)
    
    can_proceed, limit_message, _ = await check_and_log_request_attempt(user_id, current_model_key)
    
    if not can_proceed:
        # –ï—Å–ª–∏ –ª–∏–º–∏—Ç –∏—Å—á–µ—Ä–ø–∞–Ω, check_and_log_request_attempt —É–∂–µ –º–æ–≥ —Å–º–µ–Ω–∏—Ç—å –º–æ–¥–µ–ª—å –Ω–∞ –¥–µ—Ñ–æ–ª—Ç–Ω—É—é
        # –ü–æ—ç—Ç–æ–º—É –æ–±–Ω–æ–≤–ª—è–µ–º user_data_cache, —á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –º–µ–Ω—é
        user_data_cache_after_reset = await firestore_service.get_user_data(user_id)
        current_menu_after_reset = user_data_cache_after_reset.get('current_menu', BotConstants.MENU_MAIN)
        await update.message.reply_text(
            limit_message, 
            parse_mode=ParseMode.HTML, 
            reply_markup=generate_menu_keyboard(current_menu_after_reset), 
            disable_web_page_preview=True
        )
        return

    # –ü–æ–ª—É—á–∞–µ–º –∫–ª—é—á –º–æ–¥–µ–ª–∏ –µ—â–µ —Ä–∞–∑ –Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ check_and_log_request_attempt —Å–º–µ–Ω–∏–ª –µ–≥–æ
    current_model_key = await get_current_model_key(user_id, user_data_cache)
    ai_service = get_ai_service(current_model_key)

    if not ai_service:
        logger.critical(f"Could not get AI service for model key '{current_model_key}'")
        current_menu = user_data_cache.get('current_menu', BotConstants.MENU_MAIN)
        await update.message.reply_text(
            "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–±–æ—Ä–µ AI –º–æ–¥–µ–ª–∏. –°–æ–æ–±—â–∏—Ç–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.",
            reply_markup=generate_menu_keyboard(current_menu)
        )
        return

    await context.bot.send_chat_action(chat_id=update.effective_chat.id, action=ChatAction.TYPING)
    
    mode_details = await get_current_mode_details(user_id, user_data_cache)
    system_prompt = mode_details["prompt"]
    
    try:
        ai_response_text = await ai_service.generate_response(system_prompt, user_message_text)
    except Exception as e:
        logger.error(f"Unhandled exception in AI service for model {current_model_key}: {e}", exc_info=True)
        ai_response_text = f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."

    final_reply_text, _ = smart_truncate(ai_response_text, CONFIG.MAX_MESSAGE_LENGTH_TELEGRAM)
    await increment_request_count(user_id, current_model_key)
    
    current_menu = user_data_cache.get('current_menu', BotConstants.MENU_MAIN)
    await update.message.reply_text(
        final_reply_text, 
        reply_markup=generate_menu_keyboard(current_menu), 
        disable_web_page_preview=True
    )
    

# --- –û–ë–†–ê–ë–û–¢–ß–ò–ö –û–®–ò–ë–û–ö ---
async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    # ... (–∫–æ–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π, –æ–Ω –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Å –∏–º–ø–æ—Ä—Ç–∞–º–∏ –∏–∑ config) ...
    logger.error(msg="Exception while handling an update:", exc_info=context.error)
    # ... (–ª–æ–≥–∏–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É) ...
